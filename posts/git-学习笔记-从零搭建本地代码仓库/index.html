<!DOCTYPE html><html lang="zh-CN" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Git 学习笔记 从零搭建本地代码仓库" /><meta name="author" content="Ymjie" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="从零搭建本地代码仓库 git init git init 命令创建一个新的 Git 仓库。它用来将已存在但还没有版本控制的项目转换成一个 Git 仓库，或者创建一个空的新仓库。 用法 1 git init &lt;directory&gt; 在指定目录创建一个空的 Git 仓库。运行这个命令会创建一个名为 directory，只包含 .git 子目录的空目录。 1 git init --bare &lt;directory&gt; 初始化一个裸的 Git 仓库，但是忽略工作目录。共享的仓库应该总是用 --bare 标记创建（见下面的讨论）。一般来说，用 —bare 标记初始化的仓库以 .git 结尾。比如，一个叫my-project的仓库，它的空版本应该保存在 my-project.git 目录下。 讨论 对大多数项目来说，git init 只需要在创建中央仓库时执行一次——开发者通常不会使用 git init 来创建他们的本地仓库。他们往往使用 git clone 来将已存在的仓库拷贝到他们的机器中去。 git clone clone 自动创建了一个名为 origin 的远程连接，指向原有仓库。这让和中央仓库之间的交互更加简单。 用法 1 git clone &lt;repo&gt; 将位于 &lt;repo&gt; 的仓库克隆到本地机器。原仓库可以在本地文件系统中，或是通过 HTTP 或 SSH 连接的远程机器。 1 git clone &lt;repo&gt; &lt;directory&gt; 将位于 &lt;repo&gt; 的仓库克隆到本地机器上的 &lt;directory&gt; 目录。 git config git config 命令允许你在命令行中配置你的 Git 安装（或是一个独立仓库）。这个命令定义了所有配置，从用户信息到仓库行为等等。一些常见的配置命令如下所列。 用法 1 git config user.name &lt;name&gt; 定义当前仓库所有提交使用的作者姓名。通常来说，你希望使用 --global 标记设置当前用户的配置项。 1 git config --global user.name &lt;name&gt; 定义当前用户所有提交使用的作者姓名。 1 git config --global user.email &lt;email&gt; 定义当前用户所有提交使用的作者邮箱。 1 git config --global alias.&lt;alias-name&gt; &lt;git-command&gt; 为Git命令创建一个快捷方式（别名）。 1 git config --system core.editor &lt;editor&gt; 定义当前机器所有用户使用命令时用到的文本编辑器，如 git commit。&lt;editor&gt; 参数用编辑器的启动命令（如 vi）替代。 1 git config --global --edit 用文本编辑器打开全局配置文件，手动编辑。 讨论 所有配置项都储存在纯文本文件中，所以 git config 命令其实只是一个提供便捷的命令行接口。通常，你只需要在新机器上配置一次 Git 安装，以及，你通常会想要使用 --global 标记。 Git 将配置项保存在三个单独的文件中，允许你分别对单个仓库、用户和整个系统设置。 /.git/config – 特定仓库的设置。 ~/.gitconfig – 特定用户的设置。这也是 --global 标记的设置项存放的位置。 $(prefix)/etc/gitconfig – 系统层面的设置。 当这些文件中的配置项冲突时，本地仓库设置覆盖用户设置，用户设置覆盖系统设置。如果你打开期中一份文件，你会看到下面这些： 1 2 3 4 5 6 7 8 9 10 11 [user] name = John Smith email = john@example.com [alias] st = status co = checkout br = branch up = rebase ci = commit [core] editor = vim 你可以用 git config 手动编辑这些值。 git add git add 命令将工作目录中的变化添加到缓存区。它告诉 Git 你希望下一个提交中包含这个文件的更新。不过，git add 不会实际上并不会改变你的仓库。直到你运行 git commit ，更改都没有真正被记录。 工作原理 git add 和 git commit 这两个命令组成了最基本的 Git 工作流。每个 Git 用户都必须理解这两个命令，不管团队使用的是哪种协作模型。它们的作用是将项目的诸多版本记录到仓库历史中。 一个项目的编写离不开这个基本模式：编辑、缓存和提交。首先，你在工作目录中编辑你的文件。当你想要备份当前的项目状态时，你通过 git add 来缓存更改。当你觉得这个缓存的快照没问题了，你通过 git commit 将它提交到项目历史。git reset 命令用于撤销提交或缓存的快照。 除了 git add 和 git commit 之外，git push 也是完整的 Git 协作流程中的重要一环。git push 用于将提交的更改发送到远端仓库。操作完成后，其他团队成员也可以看到这些更改。 缓存区 git add 命令最主要的作用是将工作目录中的更改添加到 Git 的缓存区。 缓存允许你把密切相关的一些更改合并成一份快照，而不是直接提交所有新的更改。也就是说你可以同时进行多个无关的更改，最后将相关的更改添加到缓存区，分成几次分别提交。对于任何版本控制系统来说，保持提交的原子性非常重要，以便于追踪 bug 以及用最小的代价撤销更改。 用法 1 git add &lt;文件&gt; 缓存 &lt;文件&gt; 中的更改，准备下次提交。 1 git add &lt;目录&gt; 添加当前目录下的所有文件到暂存区： 1 git add . 缓存 &lt;目录&gt; 下的所有更改，准备下次提交。 1 git add -p 开始交互式的缓存，你可以将某个文件的其中一处更改加入到下次提交缓存。Git 会显示一堆更改，并等待用户命令。使用 y 缓存某一处更改，使用 n 忽略某一处更改，使用 s 将某一处分割成更小的几份，使用 e 手动编辑某一处更改，使用 q 退出编辑。 git commit git commit 命令将缓存的快照提交到项目历史。提交的快照可以认为是项目安全的版本，Git 永远不会改变它们，除非你这么要求。和 git add 一样，这是最重要的 Git 命令之一。 工作原理 快照总是提交到 本地 仓库。 Git 不会强制你和中央仓库进行交互，直到你准备好了。就像缓存区是工作目录和项目历史之间的缓冲地带，每个开发者的本地仓库是他们贡献的代码和中央仓库之间的缓冲地带。 这一点改变了 Git 用户基本的开发模型。Git 开发者可以在本地仓库中积累一些提交，而不是一发生更改就直接提交到中央仓库。这种风格的协作有着诸多优点：更容易将功能切分成原子性的提交，让相关的提交组合在一起，发布到中央仓库之前整理好本地的历史。开发者得以在一个隔离的环境中工作，直到他们方便的时候再整合代码。 记录快照，而不是记录差异 SVN 和 Git 除了使用上存在巨大差异，它们底层的实现同样遵循截然不同的设计哲学。SVN 追踪文件的 变化 ，而 Git 的版本控制模型基于 快照 。比如说，一个 SVN 提交由仓库中原文件相比的差异（diff）组成。而 Git 在每次提交中记录文件的 完整内容 。 这让很多 Git 操作比 SVN 来的快得多，因为文件的某个版本不需要通过版本间的差异组装得到——每个文件完整的修改能立刻从 Git 的内部数据库中得到。 Git 的快照模型对它版本控制模型的方方面面都有着深远的影响，从分支到合并工具，再到协作工作流，以至于影响了所有特性。 用法 1 git commit 提交已经缓存的快照。它会运行文本编辑器，等待你输入提交信息。当你输入信息之后，保存文件，关闭编辑器，创建实际的提交。 1 git commit -m &quot;&lt;message&gt;&quot; 提交已经缓存的快照。但将 &lt;message&gt; 作为提交信息，而不是运行文本编辑器。 1 git commit -a 提交一份包含工作目录所有更改的快照。它只包含跟踪过的文件的更改（那些之前已经通过 git add 添加过的文件）。加了-a，在 commit 的时候，能帮你省一步 git add ，但也只是对修改和删除文件有效， 新文件还是要 git add，不然就是 untracked 状态 Git 对提交信息没有特定的格式限制，但约定俗成的格式是：在第一行用 50 个以内的字符总结这个提交，留一空行，然后详细阐述具体的更改。比如： 1 2 3 4 Change the message displayed by hello.py - Update the sayHello() function to output the user&#39;s name - Change the sayGoodbye() function to a friendlier message git diff diff 命令读入两个数据集，并输出两者之间的更改。git diff 是一个用途广泛的 Git 命令，对 Git 中的数据进行 diff 差异比较。它接受的参数可以是提交、分支和文件等数据。本文将会介绍 git diff 的常见使用场景和差异差异比较的工作流。git diff 命令通常和 git status和 git log 一同使用来分析 Git 仓库当前的状态。 读懂 diff 命令的输出 原始输出 以下栗子都是在同一个仓库中执行的。使用以下命令来创建这个仓库： 1 2 3 4 5 6 7 8 9 10 11 $:&gt; mkdir diff_test_repo $:&gt; cd diff_test_repo $:&gt; touch diff_test.txt $:&gt; echo &quot;this is a git diff test example&quot; &gt; diff_test.txt $:&gt; git init . Initialized empty Git repository in /Users/kev/code/test/.git/ $:&gt; git add diff_test.txt $:&gt; git commit -am &quot;add diff test file&quot; [master (root-commit) 6f77fc3] add diff test file 1 file changed, 1 insertion(+) create mode 100644 diff_test.txt 如果我们现在执行 git diff，我们不会看到任何输出。这和我们的预期相符，因为目前仓库里还没有任何更改。当我们创建好仓库并缓存了 diff_test.txt 文件后，我们就可以通过修改这个文件来实验 diff 命令的输出： 1 $:&gt; echo &quot;this is a diff example&quot; &gt; diff_test.txt 执行这个命令将会改变 diff_test.txt 文件的内容。修改后，你可以看到前后差异并分析输出。现在执行 git diff 命令将会产生下面的输出： 1 2 3 4 5 6 7 diff --git a/diff_test.txt b/diff_test.txt index 6b0c6cf..b37e70a 100644 --- a/diff_test.txt +++ b/diff_test.txt @@ -1 +1 @@ -this is a git diff test example +this is a diff example 现在，让我们更仔细地研究 diff 命令的输出内容。 1. 进行对比的数据源 1 diff --git a/diff_test.txt b/diff_test.txt 这一行显示了 diff 命令的数据来源。我们可以看到 a/diff_test.txt 和 b/diff_test.txt 被传给了 diff 命令。 2. 元数据 1 index 6b0c6cf..b37e70a 100644 这一行显示了一些 Git 自身的元数据。一般来说你不会用到这个信息。输出中的数字是 Git 对象的哈希版本标识。 3. 更改标记 1 2 --- a/diff_test.txt +++ b/diff_test.txt 这些行包含了每个输入来源的更改标记。如上所示，a/diff_test.txt被标记为 --- （删除），而 b/diff_test.txt 被标记为 +++（增加）。 4. 差异片段 diff 输出的剩余部分是一些差异片段。一个差异片段只显示文件中一处存在差异的区域。在这个简单的栗子中，我们只有一处差异。这些片段有自己的输出粒度语义。 1 2 3 @@ -1 +1 @@ -this is a git diff test example +this is a diff example 第一行是片段头部信息。头部信息位于每个片段开头的 @@ 标记内。头部的内容是一份对该文件更改的摘要。在这个简单的栗子中，-1 +1 表示第 1 行存在变动。在一个真实的栗子中，你会看到这样的头部： 1 @@ -34,6 +34,8 @@ 在这个头部栗子中，从 34 行起有 6 行被删除，从 34 行起有 8 行被增加。 差异片段中接下来的内容是最近进行的更改。被更改的每一行开头都有一个 + 或 - 标记，表示差异的来源版本。 -表示源于 a/diff_test.txt 的更改，+ 表示源于 b/diff_test.txt 的更改。 高亮变更内容 1. git diff --color-words git diff 有一个特别的模式，可以用更细的粒度高亮变更内容：‐‐color-words。这个模式根据空格将增加和删除的行切分成单词，然后再进行差异比较。 1 2 3 4 5 6 7 $:&gt; git diff --color-words diff --git a/diff_test.txt b/diff_test.txt index 6b0c6cf..b37e70a 100644 --- a/diff_test.txt +++ b/diff_test.txt @@ -1 +1 @@ this is agit difftest example 现在，输出中只显示存在改动的单词，增加和删除被不同颜色高亮。 2. git diff-highlight 如果你拷贝了 git 的源码，你会发现有一个 contrib 子目录。它包含了一系列 git 相关的工具和还没有选入 git 核心代码的一些有趣的东西。Diff-highlight 这个 Perl 脚本就是其中之一。它将差异输出的行进行配对，然后高亮单词中改变的字符。 1 2 3 4 5 6 7 8 $:&gt; git diff | /your/local/path/to/git-core/contrib/diff-highlight/diff-highlight diff --git a/diff_test.txt b/diff_test.txt index 6b0c6cf..b37e70a 100644 --- a/diff_test.txt +++ b/diff_test.txt @@ -1 +1 @@ -this is a git diff test example +this is a diff example 这已经是我们可以看到的最小可能更改了。 对比二进制文件 除了我们之前演示的文本文件之外， git diff 还可以用于二进制文件。不过，默认的输出并没有什么用。 1 2 $:&gt; git diff Binary files a/script.pdf and b/script.pdf differ Git 有一个功能是允许你指定一个命令行命令，在执行对比之前将二进制文件的内容转换成文本。不过在这之前你需要一些设置。首先，你需要设置 textconv 过滤器描述如何将某种类型的二进制转换成文本。我们使用的是一个叫做 pdftohtml（可以通过 homebrew 安装）的工具，它可以将你的 PDF 转换成可读的 HTML。你可以编辑 .git/config 文件为某个特定的仓库设置该过滤器，或者编辑 ~ /.gitconfig 应用至全局。 1 2 [diff &quot;pdfconv&quot;] textconv=pdftohtml -stdout 然后，你只需要将一个或多个文件名规则关联到这个 pdfconv 过滤器。你可以在仓库根目录创建一个 .gitattributes 文件来执行此操作。 1 *.pdf diff=pdfconv 配置完成后，git diff 会首先使用配置好的转换脚本运行该二进制文件，然后再对转换后的输出进行差异对比。同样的技术可以用于任意一种二进制文件来获得有意义的差异对比。例如，使用 unzip -l 或类似命令替换 pdf2html，从而解压 zip 和 jar等格式的压缩文件，你可以看到不同提交镜像中新增或删除文件的路径；使用 exiv2 显示图像尺寸等元数据改动；另外还有转换工具可以将 .odf、.doc 和其他格式的文档转换成纯文本文件。简而言之，对于没有严格转换器的二进制文件来说，我们通常可以转换成字符串。 对比特定文件 git diff 命令可以传入一个显式的文件路径选项。当文件路径被传入 git diff 命令时，diff 操作将会被限定在某个特定的文件。下面这个例子展示了这种用法。 1 git diff HEAD ./path/to/file 这个例子中，该命令的作用域在使用时被限制在 ./path/to/file，它会对比工作目录和缓存区下特定的修改，显示尚未缓存的修改。默认情况下，git diff 的对比是相较 HEAD 而言。忽略上述例子中的 HEAD 后的git diff ./path/to/file 命令有着相同作用。 1 git diff --cached ./path/to/file 如果在 git diff 执行时使用 --cached 选项，该命令会对比本地仓库和缓存区中的差异。--cached 选项与 --staged 同义。 对比所有更改 不加文件路径的 git diff 命令会对比仓库中所有的更改。上述针对特定文件的栗子，在执行时也可以移除 ./path/to/file 参数从而使本地仓库中所有文件获得相同的输出。 上次提交之后的更改 默认情况下， git diff 会显示上次提交后所有未提交的更改。 1 git diff 两次提交之间的更改 git diff 可以将 Git 提交引用传给 diff 命令。例如，引用包括 HEAD、标签和分支名称。每个 Git 中的提交都有一个提交编号，你就有执行 git log 命令获得。你也可以将这个编号传给 git diff。 1 2 3 4 5 6 $:&gt; git log --prety=oneline 957fbc92b123030c389bf8b4b874522bdf2db72c add feature ce489262a1ee34340440e55a0b99ea6918e19e7a rename some classes 6b539f280d8b0ec4874671bae9c6bed80b788006 refactor some code for feature 646e7863348a427e1ed9163a9a96fa759112f102 add some copy to body $:&gt; git diff 957fbc92b123030c389bf8b4b874522bdf2db72c ce489262a1ee34340440e55a0b99ea6918e19e7a 对比分支 对比两个分支 分支的比较与其他传给 git diff 的引用相同： 1 git diff branch1..other-feature-branch 这个栗子引入了“点”操作符。其中两个点表示 diff 的输入是两个分支的顶端。当你用空格替代这两个点时，它们的效果相同。另外还有三点操作符： This example introduces the dot operator. The two dots in this example indicate the diff input is the tips of both branches. The same effect happens if the dots are omitted and a space is used between the branches. Additionally, there is a three dot operator: 1 git diff branch1...other-feature-branch 三点操作符首先将第一个输入参数 branch1 修改成两个 diff 输入 branch1 分支和 other-feature-branch 分支的共同公共祖先的引用。最后一个输入参数保留不变，为 other-feature-branch 分支的顶端。 对比两个分支中的文件 将文件名作为第三个参数传入 git diff 命令，以比较不同分支上的同一文件： 1 git diff master new_branch ./diff_test.txt 总结 本文讨论了 Git 差异比较的过程和 git diff 命令。我们讨论了如何阅读 git diff 输出和输出中的各种数据。我们举例讨论了如何为 git diff 输出加上高亮和颜色。我们太累了不同的差异对比策略，例如如何对比分支和特定提交上的更改。除了 git diff 命令外，我们还使用了 git log 和 git checkout。" /><meta property="og:description" content="从零搭建本地代码仓库 git init git init 命令创建一个新的 Git 仓库。它用来将已存在但还没有版本控制的项目转换成一个 Git 仓库，或者创建一个空的新仓库。 用法 1 git init &lt;directory&gt; 在指定目录创建一个空的 Git 仓库。运行这个命令会创建一个名为 directory，只包含 .git 子目录的空目录。 1 git init --bare &lt;directory&gt; 初始化一个裸的 Git 仓库，但是忽略工作目录。共享的仓库应该总是用 --bare 标记创建（见下面的讨论）。一般来说，用 —bare 标记初始化的仓库以 .git 结尾。比如，一个叫my-project的仓库，它的空版本应该保存在 my-project.git 目录下。 讨论 对大多数项目来说，git init 只需要在创建中央仓库时执行一次——开发者通常不会使用 git init 来创建他们的本地仓库。他们往往使用 git clone 来将已存在的仓库拷贝到他们的机器中去。 git clone clone 自动创建了一个名为 origin 的远程连接，指向原有仓库。这让和中央仓库之间的交互更加简单。 用法 1 git clone &lt;repo&gt; 将位于 &lt;repo&gt; 的仓库克隆到本地机器。原仓库可以在本地文件系统中，或是通过 HTTP 或 SSH 连接的远程机器。 1 git clone &lt;repo&gt; &lt;directory&gt; 将位于 &lt;repo&gt; 的仓库克隆到本地机器上的 &lt;directory&gt; 目录。 git config git config 命令允许你在命令行中配置你的 Git 安装（或是一个独立仓库）。这个命令定义了所有配置，从用户信息到仓库行为等等。一些常见的配置命令如下所列。 用法 1 git config user.name &lt;name&gt; 定义当前仓库所有提交使用的作者姓名。通常来说，你希望使用 --global 标记设置当前用户的配置项。 1 git config --global user.name &lt;name&gt; 定义当前用户所有提交使用的作者姓名。 1 git config --global user.email &lt;email&gt; 定义当前用户所有提交使用的作者邮箱。 1 git config --global alias.&lt;alias-name&gt; &lt;git-command&gt; 为Git命令创建一个快捷方式（别名）。 1 git config --system core.editor &lt;editor&gt; 定义当前机器所有用户使用命令时用到的文本编辑器，如 git commit。&lt;editor&gt; 参数用编辑器的启动命令（如 vi）替代。 1 git config --global --edit 用文本编辑器打开全局配置文件，手动编辑。 讨论 所有配置项都储存在纯文本文件中，所以 git config 命令其实只是一个提供便捷的命令行接口。通常，你只需要在新机器上配置一次 Git 安装，以及，你通常会想要使用 --global 标记。 Git 将配置项保存在三个单独的文件中，允许你分别对单个仓库、用户和整个系统设置。 /.git/config – 特定仓库的设置。 ~/.gitconfig – 特定用户的设置。这也是 --global 标记的设置项存放的位置。 $(prefix)/etc/gitconfig – 系统层面的设置。 当这些文件中的配置项冲突时，本地仓库设置覆盖用户设置，用户设置覆盖系统设置。如果你打开期中一份文件，你会看到下面这些： 1 2 3 4 5 6 7 8 9 10 11 [user] name = John Smith email = john@example.com [alias] st = status co = checkout br = branch up = rebase ci = commit [core] editor = vim 你可以用 git config 手动编辑这些值。 git add git add 命令将工作目录中的变化添加到缓存区。它告诉 Git 你希望下一个提交中包含这个文件的更新。不过，git add 不会实际上并不会改变你的仓库。直到你运行 git commit ，更改都没有真正被记录。 工作原理 git add 和 git commit 这两个命令组成了最基本的 Git 工作流。每个 Git 用户都必须理解这两个命令，不管团队使用的是哪种协作模型。它们的作用是将项目的诸多版本记录到仓库历史中。 一个项目的编写离不开这个基本模式：编辑、缓存和提交。首先，你在工作目录中编辑你的文件。当你想要备份当前的项目状态时，你通过 git add 来缓存更改。当你觉得这个缓存的快照没问题了，你通过 git commit 将它提交到项目历史。git reset 命令用于撤销提交或缓存的快照。 除了 git add 和 git commit 之外，git push 也是完整的 Git 协作流程中的重要一环。git push 用于将提交的更改发送到远端仓库。操作完成后，其他团队成员也可以看到这些更改。 缓存区 git add 命令最主要的作用是将工作目录中的更改添加到 Git 的缓存区。 缓存允许你把密切相关的一些更改合并成一份快照，而不是直接提交所有新的更改。也就是说你可以同时进行多个无关的更改，最后将相关的更改添加到缓存区，分成几次分别提交。对于任何版本控制系统来说，保持提交的原子性非常重要，以便于追踪 bug 以及用最小的代价撤销更改。 用法 1 git add &lt;文件&gt; 缓存 &lt;文件&gt; 中的更改，准备下次提交。 1 git add &lt;目录&gt; 添加当前目录下的所有文件到暂存区： 1 git add . 缓存 &lt;目录&gt; 下的所有更改，准备下次提交。 1 git add -p 开始交互式的缓存，你可以将某个文件的其中一处更改加入到下次提交缓存。Git 会显示一堆更改，并等待用户命令。使用 y 缓存某一处更改，使用 n 忽略某一处更改，使用 s 将某一处分割成更小的几份，使用 e 手动编辑某一处更改，使用 q 退出编辑。 git commit git commit 命令将缓存的快照提交到项目历史。提交的快照可以认为是项目安全的版本，Git 永远不会改变它们，除非你这么要求。和 git add 一样，这是最重要的 Git 命令之一。 工作原理 快照总是提交到 本地 仓库。 Git 不会强制你和中央仓库进行交互，直到你准备好了。就像缓存区是工作目录和项目历史之间的缓冲地带，每个开发者的本地仓库是他们贡献的代码和中央仓库之间的缓冲地带。 这一点改变了 Git 用户基本的开发模型。Git 开发者可以在本地仓库中积累一些提交，而不是一发生更改就直接提交到中央仓库。这种风格的协作有着诸多优点：更容易将功能切分成原子性的提交，让相关的提交组合在一起，发布到中央仓库之前整理好本地的历史。开发者得以在一个隔离的环境中工作，直到他们方便的时候再整合代码。 记录快照，而不是记录差异 SVN 和 Git 除了使用上存在巨大差异，它们底层的实现同样遵循截然不同的设计哲学。SVN 追踪文件的 变化 ，而 Git 的版本控制模型基于 快照 。比如说，一个 SVN 提交由仓库中原文件相比的差异（diff）组成。而 Git 在每次提交中记录文件的 完整内容 。 这让很多 Git 操作比 SVN 来的快得多，因为文件的某个版本不需要通过版本间的差异组装得到——每个文件完整的修改能立刻从 Git 的内部数据库中得到。 Git 的快照模型对它版本控制模型的方方面面都有着深远的影响，从分支到合并工具，再到协作工作流，以至于影响了所有特性。 用法 1 git commit 提交已经缓存的快照。它会运行文本编辑器，等待你输入提交信息。当你输入信息之后，保存文件，关闭编辑器，创建实际的提交。 1 git commit -m &quot;&lt;message&gt;&quot; 提交已经缓存的快照。但将 &lt;message&gt; 作为提交信息，而不是运行文本编辑器。 1 git commit -a 提交一份包含工作目录所有更改的快照。它只包含跟踪过的文件的更改（那些之前已经通过 git add 添加过的文件）。加了-a，在 commit 的时候，能帮你省一步 git add ，但也只是对修改和删除文件有效， 新文件还是要 git add，不然就是 untracked 状态 Git 对提交信息没有特定的格式限制，但约定俗成的格式是：在第一行用 50 个以内的字符总结这个提交，留一空行，然后详细阐述具体的更改。比如： 1 2 3 4 Change the message displayed by hello.py - Update the sayHello() function to output the user&#39;s name - Change the sayGoodbye() function to a friendlier message git diff diff 命令读入两个数据集，并输出两者之间的更改。git diff 是一个用途广泛的 Git 命令，对 Git 中的数据进行 diff 差异比较。它接受的参数可以是提交、分支和文件等数据。本文将会介绍 git diff 的常见使用场景和差异差异比较的工作流。git diff 命令通常和 git status和 git log 一同使用来分析 Git 仓库当前的状态。 读懂 diff 命令的输出 原始输出 以下栗子都是在同一个仓库中执行的。使用以下命令来创建这个仓库： 1 2 3 4 5 6 7 8 9 10 11 $:&gt; mkdir diff_test_repo $:&gt; cd diff_test_repo $:&gt; touch diff_test.txt $:&gt; echo &quot;this is a git diff test example&quot; &gt; diff_test.txt $:&gt; git init . Initialized empty Git repository in /Users/kev/code/test/.git/ $:&gt; git add diff_test.txt $:&gt; git commit -am &quot;add diff test file&quot; [master (root-commit) 6f77fc3] add diff test file 1 file changed, 1 insertion(+) create mode 100644 diff_test.txt 如果我们现在执行 git diff，我们不会看到任何输出。这和我们的预期相符，因为目前仓库里还没有任何更改。当我们创建好仓库并缓存了 diff_test.txt 文件后，我们就可以通过修改这个文件来实验 diff 命令的输出： 1 $:&gt; echo &quot;this is a diff example&quot; &gt; diff_test.txt 执行这个命令将会改变 diff_test.txt 文件的内容。修改后，你可以看到前后差异并分析输出。现在执行 git diff 命令将会产生下面的输出： 1 2 3 4 5 6 7 diff --git a/diff_test.txt b/diff_test.txt index 6b0c6cf..b37e70a 100644 --- a/diff_test.txt +++ b/diff_test.txt @@ -1 +1 @@ -this is a git diff test example +this is a diff example 现在，让我们更仔细地研究 diff 命令的输出内容。 1. 进行对比的数据源 1 diff --git a/diff_test.txt b/diff_test.txt 这一行显示了 diff 命令的数据来源。我们可以看到 a/diff_test.txt 和 b/diff_test.txt 被传给了 diff 命令。 2. 元数据 1 index 6b0c6cf..b37e70a 100644 这一行显示了一些 Git 自身的元数据。一般来说你不会用到这个信息。输出中的数字是 Git 对象的哈希版本标识。 3. 更改标记 1 2 --- a/diff_test.txt +++ b/diff_test.txt 这些行包含了每个输入来源的更改标记。如上所示，a/diff_test.txt被标记为 --- （删除），而 b/diff_test.txt 被标记为 +++（增加）。 4. 差异片段 diff 输出的剩余部分是一些差异片段。一个差异片段只显示文件中一处存在差异的区域。在这个简单的栗子中，我们只有一处差异。这些片段有自己的输出粒度语义。 1 2 3 @@ -1 +1 @@ -this is a git diff test example +this is a diff example 第一行是片段头部信息。头部信息位于每个片段开头的 @@ 标记内。头部的内容是一份对该文件更改的摘要。在这个简单的栗子中，-1 +1 表示第 1 行存在变动。在一个真实的栗子中，你会看到这样的头部： 1 @@ -34,6 +34,8 @@ 在这个头部栗子中，从 34 行起有 6 行被删除，从 34 行起有 8 行被增加。 差异片段中接下来的内容是最近进行的更改。被更改的每一行开头都有一个 + 或 - 标记，表示差异的来源版本。 -表示源于 a/diff_test.txt 的更改，+ 表示源于 b/diff_test.txt 的更改。 高亮变更内容 1. git diff --color-words git diff 有一个特别的模式，可以用更细的粒度高亮变更内容：‐‐color-words。这个模式根据空格将增加和删除的行切分成单词，然后再进行差异比较。 1 2 3 4 5 6 7 $:&gt; git diff --color-words diff --git a/diff_test.txt b/diff_test.txt index 6b0c6cf..b37e70a 100644 --- a/diff_test.txt +++ b/diff_test.txt @@ -1 +1 @@ this is agit difftest example 现在，输出中只显示存在改动的单词，增加和删除被不同颜色高亮。 2. git diff-highlight 如果你拷贝了 git 的源码，你会发现有一个 contrib 子目录。它包含了一系列 git 相关的工具和还没有选入 git 核心代码的一些有趣的东西。Diff-highlight 这个 Perl 脚本就是其中之一。它将差异输出的行进行配对，然后高亮单词中改变的字符。 1 2 3 4 5 6 7 8 $:&gt; git diff | /your/local/path/to/git-core/contrib/diff-highlight/diff-highlight diff --git a/diff_test.txt b/diff_test.txt index 6b0c6cf..b37e70a 100644 --- a/diff_test.txt +++ b/diff_test.txt @@ -1 +1 @@ -this is a git diff test example +this is a diff example 这已经是我们可以看到的最小可能更改了。 对比二进制文件 除了我们之前演示的文本文件之外， git diff 还可以用于二进制文件。不过，默认的输出并没有什么用。 1 2 $:&gt; git diff Binary files a/script.pdf and b/script.pdf differ Git 有一个功能是允许你指定一个命令行命令，在执行对比之前将二进制文件的内容转换成文本。不过在这之前你需要一些设置。首先，你需要设置 textconv 过滤器描述如何将某种类型的二进制转换成文本。我们使用的是一个叫做 pdftohtml（可以通过 homebrew 安装）的工具，它可以将你的 PDF 转换成可读的 HTML。你可以编辑 .git/config 文件为某个特定的仓库设置该过滤器，或者编辑 ~ /.gitconfig 应用至全局。 1 2 [diff &quot;pdfconv&quot;] textconv=pdftohtml -stdout 然后，你只需要将一个或多个文件名规则关联到这个 pdfconv 过滤器。你可以在仓库根目录创建一个 .gitattributes 文件来执行此操作。 1 *.pdf diff=pdfconv 配置完成后，git diff 会首先使用配置好的转换脚本运行该二进制文件，然后再对转换后的输出进行差异对比。同样的技术可以用于任意一种二进制文件来获得有意义的差异对比。例如，使用 unzip -l 或类似命令替换 pdf2html，从而解压 zip 和 jar等格式的压缩文件，你可以看到不同提交镜像中新增或删除文件的路径；使用 exiv2 显示图像尺寸等元数据改动；另外还有转换工具可以将 .odf、.doc 和其他格式的文档转换成纯文本文件。简而言之，对于没有严格转换器的二进制文件来说，我们通常可以转换成字符串。 对比特定文件 git diff 命令可以传入一个显式的文件路径选项。当文件路径被传入 git diff 命令时，diff 操作将会被限定在某个特定的文件。下面这个例子展示了这种用法。 1 git diff HEAD ./path/to/file 这个例子中，该命令的作用域在使用时被限制在 ./path/to/file，它会对比工作目录和缓存区下特定的修改，显示尚未缓存的修改。默认情况下，git diff 的对比是相较 HEAD 而言。忽略上述例子中的 HEAD 后的git diff ./path/to/file 命令有着相同作用。 1 git diff --cached ./path/to/file 如果在 git diff 执行时使用 --cached 选项，该命令会对比本地仓库和缓存区中的差异。--cached 选项与 --staged 同义。 对比所有更改 不加文件路径的 git diff 命令会对比仓库中所有的更改。上述针对特定文件的栗子，在执行时也可以移除 ./path/to/file 参数从而使本地仓库中所有文件获得相同的输出。 上次提交之后的更改 默认情况下， git diff 会显示上次提交后所有未提交的更改。 1 git diff 两次提交之间的更改 git diff 可以将 Git 提交引用传给 diff 命令。例如，引用包括 HEAD、标签和分支名称。每个 Git 中的提交都有一个提交编号，你就有执行 git log 命令获得。你也可以将这个编号传给 git diff。 1 2 3 4 5 6 $:&gt; git log --prety=oneline 957fbc92b123030c389bf8b4b874522bdf2db72c add feature ce489262a1ee34340440e55a0b99ea6918e19e7a rename some classes 6b539f280d8b0ec4874671bae9c6bed80b788006 refactor some code for feature 646e7863348a427e1ed9163a9a96fa759112f102 add some copy to body $:&gt; git diff 957fbc92b123030c389bf8b4b874522bdf2db72c ce489262a1ee34340440e55a0b99ea6918e19e7a 对比分支 对比两个分支 分支的比较与其他传给 git diff 的引用相同： 1 git diff branch1..other-feature-branch 这个栗子引入了“点”操作符。其中两个点表示 diff 的输入是两个分支的顶端。当你用空格替代这两个点时，它们的效果相同。另外还有三点操作符： This example introduces the dot operator. The two dots in this example indicate the diff input is the tips of both branches. The same effect happens if the dots are omitted and a space is used between the branches. Additionally, there is a three dot operator: 1 git diff branch1...other-feature-branch 三点操作符首先将第一个输入参数 branch1 修改成两个 diff 输入 branch1 分支和 other-feature-branch 分支的共同公共祖先的引用。最后一个输入参数保留不变，为 other-feature-branch 分支的顶端。 对比两个分支中的文件 将文件名作为第三个参数传入 git diff 命令，以比较不同分支上的同一文件： 1 git diff master new_branch ./diff_test.txt 总结 本文讨论了 Git 差异比较的过程和 git diff 命令。我们讨论了如何阅读 git diff 输出和输出中的各种数据。我们举例讨论了如何为 git diff 输出加上高亮和颜色。我们太累了不同的差异对比策略，例如如何对比分支和特定提交上的更改。除了 git diff 命令外，我们还使用了 git log 和 git checkout。" /><link rel="canonical" href="https://ymjie.github.io/posts/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/" /><meta property="og:url" content="https://ymjie.github.io/posts/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/" /><meta property="og:site_name" content="Ymjie’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-06-11T11:33:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Git 学习笔记 从零搭建本地代码仓库" /><meta name="twitter:site" content="@Aatroed" /><meta name="twitter:creator" content="@Ymjie" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Ymjie"},"description":"从零搭建本地代码仓库 git init git init 命令创建一个新的 Git 仓库。它用来将已存在但还没有版本控制的项目转换成一个 Git 仓库，或者创建一个空的新仓库。 用法 1 git init &lt;directory&gt; 在指定目录创建一个空的 Git 仓库。运行这个命令会创建一个名为 directory，只包含 .git 子目录的空目录。 1 git init --bare &lt;directory&gt; 初始化一个裸的 Git 仓库，但是忽略工作目录。共享的仓库应该总是用 --bare 标记创建（见下面的讨论）。一般来说，用 —bare 标记初始化的仓库以 .git 结尾。比如，一个叫my-project的仓库，它的空版本应该保存在 my-project.git 目录下。 讨论 对大多数项目来说，git init 只需要在创建中央仓库时执行一次——开发者通常不会使用 git init 来创建他们的本地仓库。他们往往使用 git clone 来将已存在的仓库拷贝到他们的机器中去。 git clone clone 自动创建了一个名为 origin 的远程连接，指向原有仓库。这让和中央仓库之间的交互更加简单。 用法 1 git clone &lt;repo&gt; 将位于 &lt;repo&gt; 的仓库克隆到本地机器。原仓库可以在本地文件系统中，或是通过 HTTP 或 SSH 连接的远程机器。 1 git clone &lt;repo&gt; &lt;directory&gt; 将位于 &lt;repo&gt; 的仓库克隆到本地机器上的 &lt;directory&gt; 目录。 git config git config 命令允许你在命令行中配置你的 Git 安装（或是一个独立仓库）。这个命令定义了所有配置，从用户信息到仓库行为等等。一些常见的配置命令如下所列。 用法 1 git config user.name &lt;name&gt; 定义当前仓库所有提交使用的作者姓名。通常来说，你希望使用 --global 标记设置当前用户的配置项。 1 git config --global user.name &lt;name&gt; 定义当前用户所有提交使用的作者姓名。 1 git config --global user.email &lt;email&gt; 定义当前用户所有提交使用的作者邮箱。 1 git config --global alias.&lt;alias-name&gt; &lt;git-command&gt; 为Git命令创建一个快捷方式（别名）。 1 git config --system core.editor &lt;editor&gt; 定义当前机器所有用户使用命令时用到的文本编辑器，如 git commit。&lt;editor&gt; 参数用编辑器的启动命令（如 vi）替代。 1 git config --global --edit 用文本编辑器打开全局配置文件，手动编辑。 讨论 所有配置项都储存在纯文本文件中，所以 git config 命令其实只是一个提供便捷的命令行接口。通常，你只需要在新机器上配置一次 Git 安装，以及，你通常会想要使用 --global 标记。 Git 将配置项保存在三个单独的文件中，允许你分别对单个仓库、用户和整个系统设置。 /.git/config – 特定仓库的设置。 ~/.gitconfig – 特定用户的设置。这也是 --global 标记的设置项存放的位置。 $(prefix)/etc/gitconfig – 系统层面的设置。 当这些文件中的配置项冲突时，本地仓库设置覆盖用户设置，用户设置覆盖系统设置。如果你打开期中一份文件，你会看到下面这些： 1 2 3 4 5 6 7 8 9 10 11 [user] name = John Smith email = john@example.com [alias] st = status co = checkout br = branch up = rebase ci = commit [core] editor = vim 你可以用 git config 手动编辑这些值。 git add git add 命令将工作目录中的变化添加到缓存区。它告诉 Git 你希望下一个提交中包含这个文件的更新。不过，git add 不会实际上并不会改变你的仓库。直到你运行 git commit ，更改都没有真正被记录。 工作原理 git add 和 git commit 这两个命令组成了最基本的 Git 工作流。每个 Git 用户都必须理解这两个命令，不管团队使用的是哪种协作模型。它们的作用是将项目的诸多版本记录到仓库历史中。 一个项目的编写离不开这个基本模式：编辑、缓存和提交。首先，你在工作目录中编辑你的文件。当你想要备份当前的项目状态时，你通过 git add 来缓存更改。当你觉得这个缓存的快照没问题了，你通过 git commit 将它提交到项目历史。git reset 命令用于撤销提交或缓存的快照。 除了 git add 和 git commit 之外，git push 也是完整的 Git 协作流程中的重要一环。git push 用于将提交的更改发送到远端仓库。操作完成后，其他团队成员也可以看到这些更改。 缓存区 git add 命令最主要的作用是将工作目录中的更改添加到 Git 的缓存区。 缓存允许你把密切相关的一些更改合并成一份快照，而不是直接提交所有新的更改。也就是说你可以同时进行多个无关的更改，最后将相关的更改添加到缓存区，分成几次分别提交。对于任何版本控制系统来说，保持提交的原子性非常重要，以便于追踪 bug 以及用最小的代价撤销更改。 用法 1 git add &lt;文件&gt; 缓存 &lt;文件&gt; 中的更改，准备下次提交。 1 git add &lt;目录&gt; 添加当前目录下的所有文件到暂存区： 1 git add . 缓存 &lt;目录&gt; 下的所有更改，准备下次提交。 1 git add -p 开始交互式的缓存，你可以将某个文件的其中一处更改加入到下次提交缓存。Git 会显示一堆更改，并等待用户命令。使用 y 缓存某一处更改，使用 n 忽略某一处更改，使用 s 将某一处分割成更小的几份，使用 e 手动编辑某一处更改，使用 q 退出编辑。 git commit git commit 命令将缓存的快照提交到项目历史。提交的快照可以认为是项目安全的版本，Git 永远不会改变它们，除非你这么要求。和 git add 一样，这是最重要的 Git 命令之一。 工作原理 快照总是提交到 本地 仓库。 Git 不会强制你和中央仓库进行交互，直到你准备好了。就像缓存区是工作目录和项目历史之间的缓冲地带，每个开发者的本地仓库是他们贡献的代码和中央仓库之间的缓冲地带。 这一点改变了 Git 用户基本的开发模型。Git 开发者可以在本地仓库中积累一些提交，而不是一发生更改就直接提交到中央仓库。这种风格的协作有着诸多优点：更容易将功能切分成原子性的提交，让相关的提交组合在一起，发布到中央仓库之前整理好本地的历史。开发者得以在一个隔离的环境中工作，直到他们方便的时候再整合代码。 记录快照，而不是记录差异 SVN 和 Git 除了使用上存在巨大差异，它们底层的实现同样遵循截然不同的设计哲学。SVN 追踪文件的 变化 ，而 Git 的版本控制模型基于 快照 。比如说，一个 SVN 提交由仓库中原文件相比的差异（diff）组成。而 Git 在每次提交中记录文件的 完整内容 。 这让很多 Git 操作比 SVN 来的快得多，因为文件的某个版本不需要通过版本间的差异组装得到——每个文件完整的修改能立刻从 Git 的内部数据库中得到。 Git 的快照模型对它版本控制模型的方方面面都有着深远的影响，从分支到合并工具，再到协作工作流，以至于影响了所有特性。 用法 1 git commit 提交已经缓存的快照。它会运行文本编辑器，等待你输入提交信息。当你输入信息之后，保存文件，关闭编辑器，创建实际的提交。 1 git commit -m &quot;&lt;message&gt;&quot; 提交已经缓存的快照。但将 &lt;message&gt; 作为提交信息，而不是运行文本编辑器。 1 git commit -a 提交一份包含工作目录所有更改的快照。它只包含跟踪过的文件的更改（那些之前已经通过 git add 添加过的文件）。加了-a，在 commit 的时候，能帮你省一步 git add ，但也只是对修改和删除文件有效， 新文件还是要 git add，不然就是 untracked 状态 Git 对提交信息没有特定的格式限制，但约定俗成的格式是：在第一行用 50 个以内的字符总结这个提交，留一空行，然后详细阐述具体的更改。比如： 1 2 3 4 Change the message displayed by hello.py - Update the sayHello() function to output the user&#39;s name - Change the sayGoodbye() function to a friendlier message git diff diff 命令读入两个数据集，并输出两者之间的更改。git diff 是一个用途广泛的 Git 命令，对 Git 中的数据进行 diff 差异比较。它接受的参数可以是提交、分支和文件等数据。本文将会介绍 git diff 的常见使用场景和差异差异比较的工作流。git diff 命令通常和 git status和 git log 一同使用来分析 Git 仓库当前的状态。 读懂 diff 命令的输出 原始输出 以下栗子都是在同一个仓库中执行的。使用以下命令来创建这个仓库： 1 2 3 4 5 6 7 8 9 10 11 $:&gt; mkdir diff_test_repo $:&gt; cd diff_test_repo $:&gt; touch diff_test.txt $:&gt; echo &quot;this is a git diff test example&quot; &gt; diff_test.txt $:&gt; git init . Initialized empty Git repository in /Users/kev/code/test/.git/ $:&gt; git add diff_test.txt $:&gt; git commit -am &quot;add diff test file&quot; [master (root-commit) 6f77fc3] add diff test file 1 file changed, 1 insertion(+) create mode 100644 diff_test.txt 如果我们现在执行 git diff，我们不会看到任何输出。这和我们的预期相符，因为目前仓库里还没有任何更改。当我们创建好仓库并缓存了 diff_test.txt 文件后，我们就可以通过修改这个文件来实验 diff 命令的输出： 1 $:&gt; echo &quot;this is a diff example&quot; &gt; diff_test.txt 执行这个命令将会改变 diff_test.txt 文件的内容。修改后，你可以看到前后差异并分析输出。现在执行 git diff 命令将会产生下面的输出： 1 2 3 4 5 6 7 diff --git a/diff_test.txt b/diff_test.txt index 6b0c6cf..b37e70a 100644 --- a/diff_test.txt +++ b/diff_test.txt @@ -1 +1 @@ -this is a git diff test example +this is a diff example 现在，让我们更仔细地研究 diff 命令的输出内容。 1. 进行对比的数据源 1 diff --git a/diff_test.txt b/diff_test.txt 这一行显示了 diff 命令的数据来源。我们可以看到 a/diff_test.txt 和 b/diff_test.txt 被传给了 diff 命令。 2. 元数据 1 index 6b0c6cf..b37e70a 100644 这一行显示了一些 Git 自身的元数据。一般来说你不会用到这个信息。输出中的数字是 Git 对象的哈希版本标识。 3. 更改标记 1 2 --- a/diff_test.txt +++ b/diff_test.txt 这些行包含了每个输入来源的更改标记。如上所示，a/diff_test.txt被标记为 --- （删除），而 b/diff_test.txt 被标记为 +++（增加）。 4. 差异片段 diff 输出的剩余部分是一些差异片段。一个差异片段只显示文件中一处存在差异的区域。在这个简单的栗子中，我们只有一处差异。这些片段有自己的输出粒度语义。 1 2 3 @@ -1 +1 @@ -this is a git diff test example +this is a diff example 第一行是片段头部信息。头部信息位于每个片段开头的 @@ 标记内。头部的内容是一份对该文件更改的摘要。在这个简单的栗子中，-1 +1 表示第 1 行存在变动。在一个真实的栗子中，你会看到这样的头部： 1 @@ -34,6 +34,8 @@ 在这个头部栗子中，从 34 行起有 6 行被删除，从 34 行起有 8 行被增加。 差异片段中接下来的内容是最近进行的更改。被更改的每一行开头都有一个 + 或 - 标记，表示差异的来源版本。 -表示源于 a/diff_test.txt 的更改，+ 表示源于 b/diff_test.txt 的更改。 高亮变更内容 1. git diff --color-words git diff 有一个特别的模式，可以用更细的粒度高亮变更内容：‐‐color-words。这个模式根据空格将增加和删除的行切分成单词，然后再进行差异比较。 1 2 3 4 5 6 7 $:&gt; git diff --color-words diff --git a/diff_test.txt b/diff_test.txt index 6b0c6cf..b37e70a 100644 --- a/diff_test.txt +++ b/diff_test.txt @@ -1 +1 @@ this is agit difftest example 现在，输出中只显示存在改动的单词，增加和删除被不同颜色高亮。 2. git diff-highlight 如果你拷贝了 git 的源码，你会发现有一个 contrib 子目录。它包含了一系列 git 相关的工具和还没有选入 git 核心代码的一些有趣的东西。Diff-highlight 这个 Perl 脚本就是其中之一。它将差异输出的行进行配对，然后高亮单词中改变的字符。 1 2 3 4 5 6 7 8 $:&gt; git diff | /your/local/path/to/git-core/contrib/diff-highlight/diff-highlight diff --git a/diff_test.txt b/diff_test.txt index 6b0c6cf..b37e70a 100644 --- a/diff_test.txt +++ b/diff_test.txt @@ -1 +1 @@ -this is a git diff test example +this is a diff example 这已经是我们可以看到的最小可能更改了。 对比二进制文件 除了我们之前演示的文本文件之外， git diff 还可以用于二进制文件。不过，默认的输出并没有什么用。 1 2 $:&gt; git diff Binary files a/script.pdf and b/script.pdf differ Git 有一个功能是允许你指定一个命令行命令，在执行对比之前将二进制文件的内容转换成文本。不过在这之前你需要一些设置。首先，你需要设置 textconv 过滤器描述如何将某种类型的二进制转换成文本。我们使用的是一个叫做 pdftohtml（可以通过 homebrew 安装）的工具，它可以将你的 PDF 转换成可读的 HTML。你可以编辑 .git/config 文件为某个特定的仓库设置该过滤器，或者编辑 ~ /.gitconfig 应用至全局。 1 2 [diff &quot;pdfconv&quot;] textconv=pdftohtml -stdout 然后，你只需要将一个或多个文件名规则关联到这个 pdfconv 过滤器。你可以在仓库根目录创建一个 .gitattributes 文件来执行此操作。 1 *.pdf diff=pdfconv 配置完成后，git diff 会首先使用配置好的转换脚本运行该二进制文件，然后再对转换后的输出进行差异对比。同样的技术可以用于任意一种二进制文件来获得有意义的差异对比。例如，使用 unzip -l 或类似命令替换 pdf2html，从而解压 zip 和 jar等格式的压缩文件，你可以看到不同提交镜像中新增或删除文件的路径；使用 exiv2 显示图像尺寸等元数据改动；另外还有转换工具可以将 .odf、.doc 和其他格式的文档转换成纯文本文件。简而言之，对于没有严格转换器的二进制文件来说，我们通常可以转换成字符串。 对比特定文件 git diff 命令可以传入一个显式的文件路径选项。当文件路径被传入 git diff 命令时，diff 操作将会被限定在某个特定的文件。下面这个例子展示了这种用法。 1 git diff HEAD ./path/to/file 这个例子中，该命令的作用域在使用时被限制在 ./path/to/file，它会对比工作目录和缓存区下特定的修改，显示尚未缓存的修改。默认情况下，git diff 的对比是相较 HEAD 而言。忽略上述例子中的 HEAD 后的git diff ./path/to/file 命令有着相同作用。 1 git diff --cached ./path/to/file 如果在 git diff 执行时使用 --cached 选项，该命令会对比本地仓库和缓存区中的差异。--cached 选项与 --staged 同义。 对比所有更改 不加文件路径的 git diff 命令会对比仓库中所有的更改。上述针对特定文件的栗子，在执行时也可以移除 ./path/to/file 参数从而使本地仓库中所有文件获得相同的输出。 上次提交之后的更改 默认情况下， git diff 会显示上次提交后所有未提交的更改。 1 git diff 两次提交之间的更改 git diff 可以将 Git 提交引用传给 diff 命令。例如，引用包括 HEAD、标签和分支名称。每个 Git 中的提交都有一个提交编号，你就有执行 git log 命令获得。你也可以将这个编号传给 git diff。 1 2 3 4 5 6 $:&gt; git log --prety=oneline 957fbc92b123030c389bf8b4b874522bdf2db72c add feature ce489262a1ee34340440e55a0b99ea6918e19e7a rename some classes 6b539f280d8b0ec4874671bae9c6bed80b788006 refactor some code for feature 646e7863348a427e1ed9163a9a96fa759112f102 add some copy to body $:&gt; git diff 957fbc92b123030c389bf8b4b874522bdf2db72c ce489262a1ee34340440e55a0b99ea6918e19e7a 对比分支 对比两个分支 分支的比较与其他传给 git diff 的引用相同： 1 git diff branch1..other-feature-branch 这个栗子引入了“点”操作符。其中两个点表示 diff 的输入是两个分支的顶端。当你用空格替代这两个点时，它们的效果相同。另外还有三点操作符： This example introduces the dot operator. The two dots in this example indicate the diff input is the tips of both branches. The same effect happens if the dots are omitted and a space is used between the branches. Additionally, there is a three dot operator: 1 git diff branch1...other-feature-branch 三点操作符首先将第一个输入参数 branch1 修改成两个 diff 输入 branch1 分支和 other-feature-branch 分支的共同公共祖先的引用。最后一个输入参数保留不变，为 other-feature-branch 分支的顶端。 对比两个分支中的文件 将文件名作为第三个参数传入 git diff 命令，以比较不同分支上的同一文件： 1 git diff master new_branch ./diff_test.txt 总结 本文讨论了 Git 差异比较的过程和 git diff 命令。我们讨论了如何阅读 git diff 输出和输出中的各种数据。我们举例讨论了如何为 git diff 输出加上高亮和颜色。我们太累了不同的差异对比策略，例如如何对比分支和特定提交上的更改。除了 git diff 命令外，我们还使用了 git log 和 git checkout。","headline":"Git 学习笔记 从零搭建本地代码仓库","url":"https://ymjie.github.io/posts/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/","@type":"BlogPosting","dateModified":"2021-06-11T11:33:00+08:00","datePublished":"2021-06-11T11:33:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ymjie.github.io/posts/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"},"@context":"https://schema.org"}</script><title>Git 学习笔记 从零搭建本地代码仓库 | Ymjie's Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Ymjie's Blog"><meta name="application-name" content="Ymjie's Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://q1.qlogo.cn/g?b=qq&nk=209649403&s=640" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Ymjie's Blog</a></div><div class="site-subtitle font-italic">The Boy Who Shattered Time</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/Ymjie" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/Aatroed" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['i','vshex.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Git 学习笔记 从零搭建本地代码仓库</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Git 学习笔记 从零搭建本地代码仓库</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Ymjie </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Jun 11, 2021, 11:33 AM +0800" prep="on" > Jun 11 <i class="unloaded">2021-06-11T11:33:00+08:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4944 words">27 min</span></div></div><div class="post-content"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://camo.githubusercontent.com/6e52beb12c47b2972937c8ae214e21eaa3647777c28936925ebf78ca0038157c/687474703a2f2f7777772e626f6f746373732e636f6d2f702f6769742d67756964652f696d672f74726565732e706e67" class="preview-img" alt="Preview Image"><h1 id="从零搭建本地代码仓库">从零搭建本地代码仓库</h1><h2 id="git-init">git init</h2><p><code class="language-plaintext highlighter-rouge">git init</code> 命令创建一个新的 Git 仓库。它用来将已存在但还没有版本控制的项目转换成一个 Git 仓库，或者创建一个空的新仓库。</p><h3 id="用法">用法</h3><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>git init &lt;directory&gt;
</pre></table></code></div></div><p>在指定目录创建一个空的 Git 仓库。运行这个命令会创建一个名为 <code class="language-plaintext highlighter-rouge">directory</code>，只包含 <code class="language-plaintext highlighter-rouge">.git</code> 子目录的空目录。</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>git init <span class="nt">--bare</span> &lt;directory&gt;
</pre></table></code></div></div><p>初始化一个裸的 Git 仓库，但是忽略工作目录。共享的仓库应该总是用 <code class="language-plaintext highlighter-rouge">--bare</code> 标记创建（见下面的讨论）。一般来说，用 <code class="language-plaintext highlighter-rouge">—bare</code> 标记初始化的仓库以 <code class="language-plaintext highlighter-rouge">.git</code> 结尾。比如，一个叫<code class="language-plaintext highlighter-rouge">my-project</code>的仓库，它的空版本应该保存在 <code class="language-plaintext highlighter-rouge">my-project.git</code> 目录下。</p><h3 id="讨论">讨论</h3><p>对大多数项目来说，<code class="language-plaintext highlighter-rouge">git init</code> 只需要在创建中央仓库时执行一次——开发者通常不会使用 <code class="language-plaintext highlighter-rouge">git init</code> 来创建他们的本地仓库。他们往往使用 <code class="language-plaintext highlighter-rouge">git clone</code> 来将已存在的仓库拷贝到他们的机器中去。</p><h2 id="git-clone">git clone</h2><p><code class="language-plaintext highlighter-rouge">clone</code> 自动创建了一个名为 <code class="language-plaintext highlighter-rouge">origin</code> 的远程连接，指向原有仓库。这让和中央仓库之间的交互更加简单。</p><h3 id="用法-1">用法</h3><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>git clone &lt;repo&gt;
</pre></table></code></div></div><p>将位于 <code class="language-plaintext highlighter-rouge">&lt;repo&gt;</code> 的仓库克隆到本地机器。原仓库可以在本地文件系统中，或是通过 HTTP 或 SSH 连接的远程机器。</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>git clone &lt;repo&gt; &lt;directory&gt;
</pre></table></code></div></div><p>将位于 <code class="language-plaintext highlighter-rouge">&lt;repo&gt;</code> 的仓库克隆到本地机器上的 <code class="language-plaintext highlighter-rouge">&lt;directory&gt;</code> 目录。</p><h2 id="git-config">git config</h2><p><code class="language-plaintext highlighter-rouge">git config</code> 命令允许你在命令行中配置你的 Git 安装（或是一个独立仓库）。这个命令定义了所有配置，从用户信息到仓库行为等等。一些常见的配置命令如下所列。</p><h3 id="用法-2">用法</h3><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>git config user.name &lt;name&gt;
</pre></table></code></div></div><p>定义当前仓库所有提交使用的作者姓名。通常来说，你希望使用 <code class="language-plaintext highlighter-rouge">--global</code> 标记设置当前用户的配置项。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>git config --global user.name &lt;name&gt;
</pre></table></code></div></div><p>定义当前用户所有提交使用的作者姓名。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>git config --global user.email &lt;email&gt;
</pre></table></code></div></div><p>定义当前用户所有提交使用的作者邮箱。</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>git config <span class="nt">--global</span> alias.&lt;alias-name&gt; &lt;git-command&gt;
</pre></table></code></div></div><p>为Git命令创建一个快捷方式（别名）。</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>git config <span class="nt">--system</span> core.editor &lt;editor&gt;
</pre></table></code></div></div><p>定义当前机器所有用户使用命令时用到的文本编辑器，如 <code class="language-plaintext highlighter-rouge">git commit</code>。<code class="language-plaintext highlighter-rouge">&lt;editor&gt;</code> 参数用编辑器的启动命令（如 vi）替代。</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>git config <span class="nt">--global</span> <span class="nt">--edit</span>
</pre></table></code></div></div><p>用文本编辑器打开全局配置文件，手动编辑。</p><h3 id="讨论-1">讨论</h3><p>所有配置项都储存在纯文本文件中，所以 <code class="language-plaintext highlighter-rouge">git config</code> 命令其实只是一个提供便捷的命令行接口。通常，你只需要在新机器上配置一次 Git 安装，以及，你通常会想要使用 <code class="language-plaintext highlighter-rouge">--global</code> 标记。</p><p>Git 将配置项保存在三个单独的文件中，允许你分别对单个仓库、用户和整个系统设置。</p><ul><li><code class="language-plaintext highlighter-rouge">/.git/config</code> – 特定仓库的设置。<li><code class="language-plaintext highlighter-rouge">~/.gitconfig</code> – 特定用户的设置。这也是 <code class="language-plaintext highlighter-rouge">--global</code> 标记的设置项存放的位置。<li><code class="language-plaintext highlighter-rouge">$(prefix)/etc/gitconfig</code> – 系统层面的设置。</ul><p>当这些文件中的配置项冲突时，本地仓库设置覆盖用户设置，用户设置覆盖系统设置。如果你打开期中一份文件，你会看到下面这些：</p><div class="language-ini highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nn">[user]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">John Smith</span>
<span class="py">email</span> <span class="p">=</span> <span class="s">john@example.com</span>
<span class="nn">[alias]</span>
<span class="py">st</span> <span class="p">=</span> <span class="s">status</span>
<span class="py">co</span> <span class="p">=</span> <span class="s">checkout</span>
<span class="py">br</span> <span class="p">=</span> <span class="s">branch</span>
<span class="py">up</span> <span class="p">=</span> <span class="s">rebase</span>
<span class="py">ci</span> <span class="p">=</span> <span class="s">commit</span>
<span class="nn">[core]</span>
<span class="py">editor</span> <span class="p">=</span> <span class="s">vim</span>
</pre></table></code></div></div><p>你可以用 <code class="language-plaintext highlighter-rouge">git config</code> 手动编辑这些值。</p><h2 id="git-add">git add</h2><p><code class="language-plaintext highlighter-rouge">git add</code> 命令将工作目录中的变化添加到缓存区。它告诉 Git 你希望下一个提交中包含这个文件的更新。不过，<code class="language-plaintext highlighter-rouge">git add</code> 不会实际上并不会改变你的仓库。直到你运行 <code class="language-plaintext highlighter-rouge">git commit</code> ，更改都没有真正被记录。</p><h3 id="工作原理">工作原理</h3><p><code class="language-plaintext highlighter-rouge">git add</code> 和 <code class="language-plaintext highlighter-rouge">git commit</code> 这两个命令组成了最基本的 Git 工作流。每个 Git 用户都必须理解这两个命令，不管团队使用的是哪种协作模型。它们的作用是将项目的诸多版本记录到仓库历史中。</p><p>一个项目的编写离不开这个基本模式：编辑、缓存和提交。首先，你在工作目录中编辑你的文件。当你想要备份当前的项目状态时，你通过 <code class="language-plaintext highlighter-rouge">git add</code> 来缓存更改。当你觉得这个缓存的快照没问题了，你通过 <code class="language-plaintext highlighter-rouge">git commit</code> 将它提交到项目历史。<code class="language-plaintext highlighter-rouge">git reset</code> 命令用于撤销提交或缓存的快照。</p><p>除了 <code class="language-plaintext highlighter-rouge">git add</code> 和 <code class="language-plaintext highlighter-rouge">git commit</code> 之外，<code class="language-plaintext highlighter-rouge">git push</code> 也是完整的 Git 协作流程中的重要一环。<code class="language-plaintext highlighter-rouge">git push</code> 用于将提交的更改发送到远端仓库。操作完成后，其他团队成员也可以看到这些更改。 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://wac-cdn.atlassian.com/dam/jcr:0f27e004-f2f5-4890-921d-65fa77ba2774/01.svg" alt="Git Tutorial: git add Snapshot" /></p><h3 id="缓存区">缓存区</h3><p><code class="language-plaintext highlighter-rouge">git add</code> 命令最主要的作用是将工作目录中的更改添加到 Git 的缓存区。</p><p>缓存允许你把密切相关的一些更改合并成一份快照，而不是直接提交所有新的更改。也就是说你可以同时进行多个无关的更改，最后将相关的更改添加到缓存区，分成几次分别提交。对于任何版本控制系统来说，保持提交的原子性非常重要，以便于追踪 bug 以及用最小的代价撤销更改。</p><h3 id="用法-3">用法</h3><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>git add &lt;文件&gt;
</pre></table></code></div></div><p>缓存 <code class="language-plaintext highlighter-rouge">&lt;文件&gt;</code> 中的更改，准备下次提交。</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>git add &lt;目录&gt;
</pre></table></code></div></div><p>添加当前目录下的所有文件到暂存区：</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>git add <span class="nb">.</span>
</pre></table></code></div></div><p>缓存 <code class="language-plaintext highlighter-rouge">&lt;目录&gt;</code> 下的所有更改，准备下次提交。</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>git add <span class="nt">-p</span>
</pre></table></code></div></div><p>开始交互式的缓存，你可以将某个文件的其中一处更改加入到下次提交缓存。Git 会显示一堆更改，并等待用户命令。使用 <code class="language-plaintext highlighter-rouge">y</code> 缓存某一处更改，使用 <code class="language-plaintext highlighter-rouge">n</code> 忽略某一处更改，使用 <code class="language-plaintext highlighter-rouge">s</code> 将某一处分割成更小的几份，使用 <code class="language-plaintext highlighter-rouge">e</code> 手动编辑某一处更改，使用 <code class="language-plaintext highlighter-rouge">q</code> 退出编辑。</p><h2 id="git-commit">git commit</h2><p><code class="language-plaintext highlighter-rouge">git commit</code> 命令将缓存的快照提交到项目历史。提交的快照可以认为是项目安全的版本，Git 永远不会改变它们，除非你这么要求。和 <code class="language-plaintext highlighter-rouge">git add</code> 一样，这是最重要的 Git 命令之一。</p><h3 id="工作原理-1">工作原理</h3><p>快照总是提交到 <em>本地</em> 仓库。 Git 不会强制你和中央仓库进行交互，直到你准备好了。就像缓存区是工作目录和项目历史之间的缓冲地带，每个开发者的本地仓库是他们贡献的代码和中央仓库之间的缓冲地带。</p><p>这一点改变了 Git 用户基本的开发模型。Git 开发者可以在本地仓库中积累一些提交，而不是一发生更改就直接提交到中央仓库。这种风格的协作有着诸多优点：更容易将功能切分成原子性的提交，让相关的提交组合在一起，发布到中央仓库之前整理好本地的历史。开发者得以在一个隔离的环境中工作，直到他们方便的时候再整合代码。</p><h4 id="记录快照而不是记录差异">记录快照，而不是记录差异</h4><p>SVN 和 Git 除了使用上存在巨大差异，它们底层的实现同样遵循截然不同的设计哲学。SVN 追踪文件的 <em>变化</em> ，而 Git 的版本控制模型基于 <em>快照</em> 。比如说，一个 SVN 提交由仓库中原文件相比的差异（diff）组成。而 Git 在每次提交中记录文件的 <em>完整内容</em> 。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://www.atlassian.com/dam/jcr:7406fe56-d36d-44cf-92e3-b28e4bae36f8/02.svg" alt="Git Tutorial: Snapshots, Not Differences" /></p><p>这让很多 Git 操作比 SVN 来的快得多，因为文件的某个版本不需要通过版本间的差异组装得到——每个文件完整的修改能立刻从 Git 的内部数据库中得到。</p><p>Git 的快照模型对它版本控制模型的方方面面都有着深远的影响，从分支到合并工具，再到协作工作流，以至于影响了所有特性。</p><h3 id="用法-4">用法</h3><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>git commit
</pre></table></code></div></div><p>提交已经缓存的快照。它会运行文本编辑器，等待你输入提交信息。当你输入信息之后，保存文件，关闭编辑器，创建实际的提交。</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>git commit <span class="nt">-m</span> <span class="s2">"&lt;message&gt;"</span>
</pre></table></code></div></div><p>提交已经缓存的快照。但将 <code class="language-plaintext highlighter-rouge">&lt;message&gt;</code> 作为提交信息，而不是运行文本编辑器。</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>git commit <span class="nt">-a</span>
</pre></table></code></div></div><p>提交一份包含工作目录所有更改的快照。它只包含跟踪过的文件的更改（那些之前已经通过 <code class="language-plaintext highlighter-rouge">git add</code> 添加过的文件）。加了-a，在 commit 的时候，能帮你省一步 git add ，但也只是对<strong>修改</strong>和<strong>删除</strong>文件有效， 新文件还是要 git add，不然就是 untracked 状态</p><p>Git 对提交信息没有特定的格式限制，但约定俗成的格式是：在第一行用 50 个以内的字符总结这个提交，留一空行，然后详细阐述具体的更改。比如：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Change the message displayed by hello.py
<span class="p">
-</span> Update the sayHello() function to output the user's name
<span class="p">-</span> Change the sayGoodbye() function to a friendlier message
</pre></table></code></div></div><h2 id="git-diff">git diff</h2><p><code class="language-plaintext highlighter-rouge">diff</code> 命令读入两个数据集，并输出两者之间的更改。<code class="language-plaintext highlighter-rouge">git diff</code> 是一个用途广泛的 Git 命令，对 Git 中的数据进行 <code class="language-plaintext highlighter-rouge">diff</code> 差异比较。它接受的参数可以是提交、分支和文件等数据。本文将会介绍 <code class="language-plaintext highlighter-rouge">git diff</code> 的常见使用场景和差异差异比较的工作流。<code class="language-plaintext highlighter-rouge">git diff</code> 命令通常和 <code class="language-plaintext highlighter-rouge">git status</code>和 <code class="language-plaintext highlighter-rouge">git log</code> 一同使用来分析 Git 仓库当前的状态。</p><h3 id="读懂-diff-命令的输出">读懂 diff 命令的输出</h3><h4 id="原始输出">原始输出</h4><p>以下栗子都是在同一个仓库中执行的。使用以下命令来创建这个仓库：</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nv">$:</span><span class="o">&gt;</span> <span class="nb">mkdir </span>diff_test_repo
<span class="nv">$:</span><span class="o">&gt;</span> <span class="nb">cd </span>diff_test_repo
<span class="nv">$:</span><span class="o">&gt;</span> <span class="nb">touch </span>diff_test.txt
<span class="nv">$:</span><span class="o">&gt;</span> <span class="nb">echo</span> <span class="s2">"this is a git diff test example"</span> <span class="o">&gt;</span> diff_test.txt
<span class="nv">$:</span><span class="o">&gt;</span> git init <span class="nb">.</span>
Initialized empty Git repository <span class="k">in</span> /Users/kev/code/test/.git/
<span class="nv">$:</span><span class="o">&gt;</span> git add diff_test.txt
<span class="nv">$:</span><span class="o">&gt;</span> git commit <span class="nt">-am</span> <span class="s2">"add diff test file"</span>
<span class="o">[</span>master <span class="o">(</span>root-commit<span class="o">)</span> 6f77fc3] add diff <span class="nb">test </span>file
1 file changed, 1 insertion<span class="o">(</span>+<span class="o">)</span>
create mode 100644 diff_test.txt
</pre></table></code></div></div><p>如果我们现在执行 <code class="language-plaintext highlighter-rouge">git diff</code>，我们不会看到任何输出。这和我们的预期相符，因为目前仓库里还没有任何更改。当我们创建好仓库并缓存了 <code class="language-plaintext highlighter-rouge">diff_test.txt</code> 文件后，我们就可以通过修改这个文件来实验 diff 命令的输出：</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$:</span><span class="o">&gt;</span> <span class="nb">echo</span> <span class="s2">"this is a diff example"</span> <span class="o">&gt;</span> diff_test.txt
</pre></table></code></div></div><p>执行这个命令将会改变 <code class="language-plaintext highlighter-rouge">diff_test.txt</code> 文件的内容。修改后，你可以看到前后差异并分析输出。现在执行 <code class="language-plaintext highlighter-rouge">git diff</code> 命令将会产生下面的输出：</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>diff <span class="nt">--git</span> a/diff_test.txt b/diff_test.txt
index 6b0c6cf..b37e70a 100644
<span class="nt">---</span> a/diff_test.txt
+++ b/diff_test.txt
@@ <span class="nt">-1</span> +1 @@
<span class="nt">-this</span> is a git diff <span class="nb">test </span>example
+this is a diff example
</pre></table></code></div></div><p>现在，让我们更仔细地研究 diff 命令的输出内容。</p><h4 id="1-进行对比的数据源">1. 进行对比的数据源</h4><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>diff <span class="nt">--git</span> a/diff_test.txt b/diff_test.txt
</pre></table></code></div></div><p>这一行显示了 diff 命令的数据来源。我们可以看到 <code class="language-plaintext highlighter-rouge">a/diff_test.txt</code> 和 <code class="language-plaintext highlighter-rouge">b/diff_test.txt</code> 被传给了 diff 命令。</p><h4 id="2-元数据">2. 元数据</h4><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>index 6b0c6cf..b37e70a 100644
</pre></table></code></div></div><p>这一行显示了一些 Git 自身的元数据。一般来说你不会用到这个信息。输出中的数字是 Git 对象的哈希版本标识。</p><h4 id="3-更改标记">3. 更改标记</h4><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nt">---</span> a/diff_test.txt
+++ b/diff_test.txt
</pre></table></code></div></div><p>这些行包含了每个输入来源的更改标记。如上所示，<code class="language-plaintext highlighter-rouge">a/diff_test.txt</code>被标记为 <code class="language-plaintext highlighter-rouge">---</code> （删除），而 <code class="language-plaintext highlighter-rouge">b/diff_test.txt</code> 被标记为 <code class="language-plaintext highlighter-rouge">+++</code>（增加）。</p><h4 id="4-差异片段">4. 差异片段</h4><p>diff 输出的剩余部分是一些差异片段。一个差异片段只显示文件中一处存在差异的区域。在这个简单的栗子中，我们只有一处差异。这些片段有自己的输出粒度语义。</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>@@ <span class="nt">-1</span> +1 @@
<span class="nt">-this</span> is a git diff <span class="nb">test </span>example
+this is a diff example
</pre></table></code></div></div><p>第一行是片段头部信息。头部信息位于每个片段开头的 <code class="language-plaintext highlighter-rouge">@@</code> 标记内。头部的内容是一份对该文件更改的摘要。在这个简单的栗子中，-1 +1 表示第 1 行存在变动。在一个真实的栗子中，你会看到这样的头部：</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>@@ <span class="nt">-34</span>,6 +34,8 @@
</pre></table></code></div></div><p>在这个头部栗子中，从 34 行起有 6 行被删除，从 34 行起有 8 行被增加。</p><p>差异片段中接下来的内容是最近进行的更改。被更改的每一行开头都有一个 <code class="language-plaintext highlighter-rouge">+</code> 或 <code class="language-plaintext highlighter-rouge">-</code> 标记，表示差异的来源版本。 <code class="language-plaintext highlighter-rouge">-</code>表示源于 <code class="language-plaintext highlighter-rouge">a/diff_test.txt</code> 的更改，+ 表示源于 <code class="language-plaintext highlighter-rouge">b/diff_test.txt</code> 的更改。</p><h3 id="高亮变更内容">高亮变更内容</h3><h4 id="1-git-diff---color-words">1. <code class="language-plaintext highlighter-rouge">git diff --color-words</code></h4><p><code class="language-plaintext highlighter-rouge">git diff</code> 有一个特别的模式，可以用更细的粒度高亮变更内容：<code class="language-plaintext highlighter-rouge">‐‐color-words</code>。这个模式根据空格将增加和删除的行切分成单词，然后再进行差异比较。</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nv">$:</span><span class="o">&gt;</span> git diff <span class="nt">--color-words</span>
diff <span class="nt">--git</span> a/diff_test.txt b/diff_test.txt
index 6b0c6cf..b37e70a 100644
<span class="nt">---</span> a/diff_test.txt
+++ b/diff_test.txt
@@ <span class="nt">-1</span> +1 @@
this is agit difftest example
</pre></table></code></div></div><p>现在，输出中只显示存在改动的单词，增加和删除被不同颜色高亮。</p><h4 id="2-git-diff-highlight">2. <code class="language-plaintext highlighter-rouge">git diff-highlight</code></h4><p>如果你拷贝了 git 的源码，你会发现有一个 contrib 子目录。它包含了一系列 git 相关的工具和还没有选入 git 核心代码的一些有趣的东西。Diff-highlight 这个 Perl 脚本就是其中之一。它将差异输出的行进行配对，然后高亮单词中改变的字符。</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nv">$:</span><span class="o">&gt;</span> git diff | /your/local/path/to/git-core/contrib/diff-highlight/diff-highlight
diff <span class="nt">--git</span> a/diff_test.txt b/diff_test.txt
index 6b0c6cf..b37e70a 100644
<span class="nt">---</span> a/diff_test.txt
+++ b/diff_test.txt
@@ <span class="nt">-1</span> +1 @@
<span class="nt">-this</span> is a git diff <span class="nb">test </span>example
+this is a diff example
</pre></table></code></div></div><p>这已经是我们可以看到的最小可能更改了。</p><h3 id="对比二进制文件">对比二进制文件</h3><p>除了我们之前演示的文本文件之外， <code class="language-plaintext highlighter-rouge">git diff</code> 还可以用于二进制文件。不过，默认的输出并没有什么用。</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$:</span><span class="o">&gt;</span> git diff
Binary files a/script.pdf and b/script.pdf differ
</pre></table></code></div></div><p>Git 有一个功能是允许你指定一个命令行命令，在执行对比之前将二进制文件的内容转换成文本。不过在这之前你需要一些设置。首先，你需要设置 textconv 过滤器描述如何将某种类型的二进制转换成文本。我们使用的是一个叫做 pdftohtml（可以通过 homebrew 安装）的工具，它可以将你的 PDF 转换成可读的 HTML。你可以编辑 <code class="language-plaintext highlighter-rouge">.git/config</code> 文件为某个特定的仓库设置该过滤器，或者编辑 <code class="language-plaintext highlighter-rouge">~ /.gitconfig</code> 应用至全局。</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="o">[</span>diff <span class="s2">"pdfconv"</span><span class="o">]</span>
<span class="nv">textconv</span><span class="o">=</span>pdftohtml <span class="nt">-stdout</span>
</pre></table></code></div></div><p>然后，你只需要将一个或多个文件名规则关联到这个 pdfconv 过滤器。你可以在仓库根目录创建一个 <code class="language-plaintext highlighter-rouge">.gitattributes</code> 文件来执行此操作。</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">*</span>.pdf <span class="nv">diff</span><span class="o">=</span>pdfconv
</pre></table></code></div></div><p>配置完成后，<code class="language-plaintext highlighter-rouge">git diff</code> 会首先使用配置好的转换脚本运行该二进制文件，然后再对转换后的输出进行差异对比。同样的技术可以用于任意一种二进制文件来获得有意义的差异对比。例如，使用 <code class="language-plaintext highlighter-rouge">unzip -l</code> 或类似命令替换 pdf2html，从而解压 zip 和 jar等格式的压缩文件，你可以看到不同提交镜像中新增或删除文件的路径；使用 exiv2 显示图像尺寸等元数据改动；另外还有转换工具可以将 .odf、.doc 和其他格式的文档转换成纯文本文件。简而言之，对于没有严格转换器的二进制文件来说，我们通常可以转换成字符串。</p><h3 id="对比特定文件">对比特定文件</h3><p><code class="language-plaintext highlighter-rouge">git diff</code> 命令可以传入一个显式的文件路径选项。当文件路径被传入 <code class="language-plaintext highlighter-rouge">git diff</code> 命令时，diff 操作将会被限定在某个特定的文件。下面这个例子展示了这种用法。</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>git diff HEAD ./path/to/file
</pre></table></code></div></div><p>这个例子中，该命令的作用域在使用时被限制在 <code class="language-plaintext highlighter-rouge">./path/to/file</code>，它会对比工作目录和缓存区下特定的修改，显示尚未缓存的修改。默认情况下，<code class="language-plaintext highlighter-rouge">git diff</code> 的对比是相较 <code class="language-plaintext highlighter-rouge">HEAD</code> 而言。忽略上述例子中的 <code class="language-plaintext highlighter-rouge">HEAD</code> 后的<code class="language-plaintext highlighter-rouge">git diff ./path/to/file</code> 命令有着相同作用。</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>git diff <span class="nt">--cached</span> ./path/to/file
</pre></table></code></div></div><p>如果在 <code class="language-plaintext highlighter-rouge">git diff</code> 执行时使用 <code class="language-plaintext highlighter-rouge">--cached</code> 选项，该命令会对比本地仓库和缓存区中的差异。<code class="language-plaintext highlighter-rouge">--cached</code> 选项与 <code class="language-plaintext highlighter-rouge">--staged</code> 同义。</p><h3 id="对比所有更改">对比所有更改</h3><p>不加文件路径的 <code class="language-plaintext highlighter-rouge">git diff</code> 命令会对比仓库中所有的更改。上述针对特定文件的栗子，在执行时也可以移除 <code class="language-plaintext highlighter-rouge">./path/to/file</code> 参数从而使本地仓库中所有文件获得相同的输出。</p><h3 id="上次提交之后的更改">上次提交之后的更改</h3><p>默认情况下， <code class="language-plaintext highlighter-rouge">git diff</code> 会显示上次提交后所有未提交的更改。</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>git diff
</pre></table></code></div></div><h3 id="两次提交之间的更改">两次提交之间的更改</h3><p><code class="language-plaintext highlighter-rouge">git diff</code> 可以将 Git 提交引用传给 diff 命令。例如，引用包括 <code class="language-plaintext highlighter-rouge">HEAD</code>、标签和分支名称。每个 Git 中的提交都有一个提交编号，你就有执行 <code class="language-plaintext highlighter-rouge">git log</code> 命令获得。你也可以将这个编号传给 <code class="language-plaintext highlighter-rouge">git diff</code>。</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nv">$:</span><span class="o">&gt;</span> git log <span class="nt">--prety</span><span class="o">=</span>oneline
957fbc92b123030c389bf8b4b874522bdf2db72c add feature
ce489262a1ee34340440e55a0b99ea6918e19e7a rename some classes
6b539f280d8b0ec4874671bae9c6bed80b788006 refactor some code <span class="k">for </span>feature
646e7863348a427e1ed9163a9a96fa759112f102 add some copy to body
<span class="nv">$:</span><span class="o">&gt;</span> git diff 957fbc92b123030c389bf8b4b874522bdf2db72c ce489262a1ee34340440e55a0b99ea6918e19e7a
</pre></table></code></div></div><h3 id="对比分支">对比分支</h3><h4 id="对比两个分支">对比两个分支</h4><p>分支的比较与其他传给 <code class="language-plaintext highlighter-rouge">git diff</code> 的引用相同：</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>git diff branch1..other-feature-branch
</pre></table></code></div></div><p>这个栗子引入了“点”操作符。其中两个点表示 diff 的输入是两个分支的顶端。当你用空格替代这两个点时，它们的效果相同。另外还有三点操作符：</p><p>This example introduces the dot operator. The two dots in this example indicate the diff input is the tips of both branches. The same effect happens if the dots are omitted and a space is used between the branches. Additionally, there is a three dot operator:</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>git diff branch1...other-feature-branch
</pre></table></code></div></div><p>三点操作符首先将第一个输入参数 <code class="language-plaintext highlighter-rouge">branch1</code> 修改成两个 diff 输入 branch1 分支和 other-feature-branch 分支的共同公共祖先的引用。最后一个输入参数保留不变，为 other-feature-branch 分支的顶端。</p><h4 id="对比两个分支中的文件">对比两个分支中的文件</h4><p>将文件名作为第三个参数传入 <code class="language-plaintext highlighter-rouge">git diff</code> 命令，以比较不同分支上的同一文件：</p><div class="language-shell highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>git diff master new_branch ./diff_test.txt
</pre></table></code></div></div><h3 id="总结">总结</h3><p>本文讨论了 Git 差异比较的过程和 <code class="language-plaintext highlighter-rouge">git diff</code> 命令。我们讨论了如何阅读 <code class="language-plaintext highlighter-rouge">git diff</code> 输出和输出中的各种数据。我们举例讨论了如何为 <code class="language-plaintext highlighter-rouge">git diff</code> 输出加上高亮和颜色。我们太累了不同的差异对比策略，例如如何对比分支和特定提交上的更改。除了 <code class="language-plaintext highlighter-rouge">git diff</code> 命令外，我们还使用了 <code class="language-plaintext highlighter-rouge">git log</code> 和 <code class="language-plaintext highlighter-rouge">git checkout</code>。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/'>学习笔记</a>, <a href='/categories/git/'>Git</a>, <a href='/categories/%E4%B8%80/'>一</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/git/" class="post-tag no-text-decoration" >git</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-tag no-text-decoration" >学习笔记</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Git 学习笔记 从零搭建本地代码仓库 - Ymjie's Blog&url=https://ymjie.github.io/posts/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Git 学习笔记 从零搭建本地代码仓库 - Ymjie's Blog&u=https://ymjie.github.io/posts/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Git 学习笔记 从零搭建本地代码仓库 - Ymjie's Blog&url=https://ymjie.github.io/posts/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/%E7%94%9F%E5%91%BD%E7%9A%84%E6%97%B6%E9%97%B4%E5%8F%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1/">生命的时间只属于自己</a><li><a href="/posts/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%AF%BC%E5%9B%BE/">HTTP协议状态码 导图</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/http/">http</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/%E7%94%9F%E5%91%BD/">生命</a> <a class="post-tag" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%AF%BC%E5%9B%BE/"><div class="card-body"> <span class="timeago small" > Jun 11 <i class="unloaded">2021-06-11T21:53:34+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>HTTP协议状态码 导图</h3><div class="text-muted small"><p></p></div></div></a></div><div class="card"> <a href="/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81-%E5%B0%81%E8%A3%85-%E7%BB%A7%E6%89%BF-%E5%A4%9A%E6%80%81-%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/"><div class="card-body"> <span class="timeago small" > Jun 27 <i class="unloaded">2021-06-27T22:53:34+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>面向对象的三大特征（封装、继承、多态）、继承详解</h3><div class="text-muted small"><p> 面向对象的三大特征（封装、继承、多态） 封装：隐藏对象的属性和实现细节，只对外提供必要的方法，相当于将“细节封装起来”，只对外暴露“相关的调用方法”。封装可以通过“私有属性、私有方法”的方式，实现封装。 继承：继承可以让子类具有父类的特性，提高了代码的复用性。继承从设计上是一个增量进化，原有父类设计不变的情况下，可以增加新的功能，或者改进已有的算法。 多态：指同一个方法调用由于对象的不同会...</p></div></div></a></div><div class="card"> <a href="/posts/%E7%94%9F%E5%91%BD%E7%9A%84%E6%97%B6%E9%97%B4%E5%8F%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1/"><div class="card-body"> <span class="timeago small" > Aug 1 <i class="unloaded">2021-08-01T16:01:34+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>生命的时间只属于自己</h3><div class="text-muted small"><p> 生命的时间只属于自己 并没有任何人可以评定任何人的“人生高度”，生命的本质是“一段生命时间”，每个人的“生命时间”只属于自己，是独有的“生命体验”，好、坏、对、错、意义、价值全由自己说了算，有且仅有自己负责。 一个人如何实现自己“生命时间”里的“生命意义”仅需要遵循自己内心的真实意愿，不由“父母”、“伴侣”、“朋友”或“外界眼光”、“观念”捆绑和评定。 充分体验自己人生过程的每一个体验...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <span class="btn btn-outline-primary disabled" prompt="Older"><p>-</p></span> <a href="/posts/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%AF%BC%E5%9B%BE/" class="btn btn-outline-primary" prompt="Newer"><p>HTTP协议状态码 导图</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//ymjblog.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Git 学习笔记 从零搭建本地代码仓库'; this.page.url = 'https://ymjie.github.io/posts/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/'; this.page.identifier = '/posts/git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/Aatroed">Ymjie</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/http/">http</a> <a class="post-tag" href="/tags/python/">Python</a> <a class="post-tag" href="/tags/%E7%94%9F%E5%91%BD/">生命</a> <a class="post-tag" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { let initTheme = "default"; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://ymjie.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
